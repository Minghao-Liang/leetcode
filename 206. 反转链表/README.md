# 206.反转链表

[题目：206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

solution1.cpp中的是迭代解法，在第一个结点设置一个指针q，第一个结点前设置一个哑结点指针p，当q不指向空指针，证明链表还没遍历借书，则在遍历中创建一个结点指针c指向q的下一个结点使得原本的`p(nullptr)-->q(head)-->c`的指向转变为q的下一个结点指向p，此时head就为最后一个结点了，然后把p和q都沿着原来链表的方向往前移，循环进行上面的过程，一个个结点迭代。
solution2.cpp中则使用了递归解法。当顺着原来的链表到达最后一个结点时，开始递归返回，然后将该前一个调用函数的结点的下一个结点指向前一个结点（通过函数参数输入为`head->next`来实现），再把前一个结点的前一个结点指向空。
